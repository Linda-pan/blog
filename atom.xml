<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Jpan的博客</title>
  
  <subtitle>静静正在学习......</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.jpan.ink/"/>
  <updated>2019-03-28T15:18:50.654Z</updated>
  <id>https://www.jpan.ink/</id>
  
  <author>
    <name>Jing Pan</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Resume</title>
    <link href="https://www.jpan.ink/2019/03/25/Resume/"/>
    <id>https://www.jpan.ink/2019/03/25/Resume/</id>
    <published>2019-03-24T16:00:00.000Z</published>
    <updated>2019-03-28T15:18:50.654Z</updated>
    
    <content type="html"><![CDATA[<div style="float:left;font-weight:bold;"><font size="5">潘静</font></div><br><div style="float:right;"><font style="font-weight:bold;">性别</font>：女 &nbsp;&nbsp;<font style="font-weight:bold;">E-mail</font>：<a href="mailto:lanrong1639@126.com" target="_blank" rel="noopener">lanrong1639@126.com</a> </div><br><br><br><div style="float:right;"><font style="font-weight:bold;">电话</font> +86-135XXXX0145 &nbsp;&nbsp;<font style="font-weight:bold;">Blog</font>：<a href="http://www.jpan.ink">www.jpan.ink</a> </div><hr><h3 id="教育背景"><a href="#教育背景" class="headerlink" title="教育背景"></a>教育背景</h3><ul><li>2012-09 ~ 2016-07    本科，上海大学计算机系。校内两次学业奖学金，平均成绩前 12%。</li></ul><hr><h3 id="工作经验"><a href="#工作经验" class="headerlink" title="工作经验"></a>工作经验</h3><p>2016-5 ~ now&nbsp;&nbsp;凯盛融英信息科技（上海）有限公司&nbsp;&nbsp;&nbsp;&nbsp;Java 工程师</p><ul><li><p>工作内容：</p><ul><li>处理业务需求；版本迭代App接口及运营网站；创建和维护报表；项目模块优化等。</li></ul></li><li><p>技术描述：</p><ul><li>4年Java，2年Python经验</li><li>熟练使用Mysql，熟悉Mysql调优</li><li>熟悉 SpringMVC + Mybatis，SpringBoot 框架</li><li>熟悉 Redis，RabbitMq，ElasticSearch，RPC，Docker</li></ul></li><li><p>工作项目</p><h5 id="nbsp-nbsp-nbsp-业务系统重构：2016-05-now主要coder之一"><a href="#nbsp-nbsp-nbsp-业务系统重构：2016-05-now主要coder之一" class="headerlink" title="&nbsp;&nbsp;&nbsp;业务系统重构：2016-05 ~ now主要coder之一"></a>&nbsp;&nbsp;&nbsp;业务系统重构：<div style="float:left;">2016-05 ~ now</div><div style="float:right;">主要coder之一</div></h5><ul><li>2016年用SSM框架将原PHP业务网站重构，我独立负责了项目和报表模块的接口。</li><li>2018年底将业务系统微服务化，我独立负责了日志、报表及美版相关数据的接口。项目为SpringBoot框架，使用了Motan的RPC服务，搭建在K8S管理的Docker服务器上<h5 id="nbsp-nbsp-nbsp-App接口及运营网站：-2017-05-now负责人"><a href="#nbsp-nbsp-nbsp-App接口及运营网站：-2017-05-now负责人" class="headerlink" title="&nbsp;&nbsp;&nbsp;App接口及运营网站：        2017-05 ~ now负责人"></a>&nbsp;&nbsp;&nbsp;App接口及运营网站：        <div style="float:left;">2017-05 ~ now</div><div style="float:right;">负责人</div></h5></li><li>第一个大版本全程跟进，包括直播功能等，使用了七牛直播间的技术。</li><li>负责之后至今APP的4个版本的迭代。提供接口有支付模块，积分模块，征集模块等。使用了Redis,RPC,RabbitMq等技术。与此同时负责运营网站的变更，主要提供App运营事务，权限控制和数据查询之类的功能。为JSP+Spring+Mybatis的框架模式。<h5 id="nbsp-nbsp-nbsp-公司业务流程优化：2017-12-2018-04主要coder之一"><a href="#nbsp-nbsp-nbsp-公司业务流程优化：2017-12-2018-04主要coder之一" class="headerlink" title="&nbsp;&nbsp;&nbsp;公司业务流程优化：2017-12 ~ 2018-04主要coder之一"></a>&nbsp;&nbsp;&nbsp;公司业务流程优化：<div style="float:left;">2017-12 ~ 2018-04</div><div style="float:right;">主要coder之一</div></h5></li><li>使用Python解析长文本得到关键词。</li><li>优化内外部搜索，内部数据优化了ElasticSearch，对外使用Python进行信息爬取。<h5 id="nbsp-nbsp-nbsp-构建财务系统：2017-09-2018-01主要coder之一"><a href="#nbsp-nbsp-nbsp-构建财务系统：2017-09-2018-01主要coder之一" class="headerlink" title="&nbsp;&nbsp;&nbsp;构建财务系统：2017-09 ~ 2018-01主要coder之一"></a>&nbsp;&nbsp;&nbsp;构建财务系统：<div style="float:left;">2017-09 ~ 2018-01</div><div style="float:right;">主要coder之一</div></h5></li><li>全程跟进将3年财务数据整理并迁入到数据库中，使用了Python和DataNitro等工具</li><li>参与开发出一套记账出票流程。与业务人员直接对接了解需求，提供后端的财务接口等</li><li>通过该项目获得了年度公司新锐奖</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      md版本的resume
    
    </summary>
    
      <category term="Resume" scheme="https://www.jpan.ink/categories/Resume/"/>
    
    
  </entry>
  
  <entry>
    <title>五种RabbitMQ队列</title>
    <link href="https://www.jpan.ink/2019/03/17/RabbitMQ-queue/"/>
    <id>https://www.jpan.ink/2019/03/17/RabbitMQ-queue/</id>
    <published>2019-03-16T16:00:00.000Z</published>
    <updated>2019-03-28T15:04:44.995Z</updated>
    
    <content type="html"><![CDATA[<h3 id="MQ"><a href="#MQ" class="headerlink" title="MQ"></a>MQ</h3><p>Message Queue<br>AMQP基础 Advanced Message Queuing Protocol<br>产品: ActiveMQ(Apache), Kafka<br><a id="more"></a></p><h3 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h3><p>解耦<br>异步</p><p>用Erlang开发  面向并发<br>支持 Java，Python, Ruby, NET, PHP, C/C++, node.js</p><h4 id="管理平台"><a href="#管理平台" class="headerlink" title="管理平台"></a>管理平台</h4><p>rabbitmq-plugins enable rabbitmq_management</p><p><img src="/2019/03/17/RabbitMQ-queue/1.png" alt=""></p><p><img src="/2019/03/17/RabbitMQ-queue/2.png" alt=""></p><p>消费者<br><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取到连接以及mq通道</span></span><br><span class="line">Connection connection = ConnectionUtil.getConnection();</span><br><span class="line">Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明队列</span></span><br><span class="line">channel.queueDeclare(QUEUE_NAME, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义队列的消费者</span></span><br><span class="line">QueueingConsumer consumer = <span class="keyword">new</span> <span class="type">QueueingConsumer</span>(channel);</span><br><span class="line"><span class="comment">// 监听队列</span></span><br><span class="line">channel.basicConsume(QUEUE_NAME, <span class="literal">true</span>, consumer);</span><br></pre></td></tr></table></figure></p><p>服务者<br><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取消息</span></span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">QueueingConsumer.Delivery delivery = consumer.nextDelivery();</span><br><span class="line"><span class="keyword">String</span> message = <span class="keyword">new</span> <span class="keyword">String</span>(delivery.getBody());</span><br><span class="line">System.out.<span class="built_in">println</span>(<span class="string">" [x] Received '"</span> + message + <span class="string">"'"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Connection connection = ConnectionUtil.getConnection();</span><br><span class="line">Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">channel.queueDeclare(QUEUE_NAME, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">String</span> message = <span class="string">"Hello Jpan1!"</span>;</span><br><span class="line">channel.basicPublish(<span class="string">""</span>, QUEUE_NAME, <span class="keyword">null</span>, message.getBytes());</span><br><span class="line">System.out.<span class="built_in">println</span>(<span class="string">" [x] Sent '"</span> + message + <span class="string">"'"</span>);</span><br><span class="line"></span><br><span class="line">channel.close();</span><br><span class="line">connection.close();</span><br></pre></td></tr></table></figure></p><p>其他</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 同一时刻服务器只会发一条消息给消费者 能者多劳 </span></span><br><span class="line"><span class="selector-tag">channel</span><span class="selector-class">.basicQos</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 确认到达</span></span><br><span class="line"><span class="selector-tag">channel</span><span class="selector-class">.basicConsume</span>(name,false,consumer)</span><br><span class="line"><span class="selector-tag">channel</span><span class="selector-class">.basicAck</span>(delivery.getEnvelope().getDeliveryTag(), false);</span><br></pre></td></tr></table></figure><p>多种队列的定义</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 生产者</span></span><br><span class="line"><span class="comment">// 声明exchange</span></span><br><span class="line">channel.exchangeDeclare(EXCHANGE_NAME, <span class="string">"fanout"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消息内容</span></span><br><span class="line"><span class="built_in">String</span> message = <span class="string">"Hello Jpan!"</span>;</span><br><span class="line">channel.basicPublish(EXCHANGE_NAME, <span class="string">""</span>, <span class="keyword">null</span>, message.getBytes());<span class="comment">//exchange 和bind结合  在发送者这里不需要定义queue</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 消费者</span></span><br><span class="line"><span class="comment">// 声明队列</span></span><br><span class="line">channel.queueDeclare(QUEUE_NAME, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绑定队列到交换机 fanout</span></span><br><span class="line">channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, <span class="string">""</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绑定队列到交换机 routing</span></span><br><span class="line">channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, <span class="string">"key"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绑定队列到交换机 topic</span></span><br><span class="line">channel.queueBind(QcolumnsUEUE_NAME, EXCHANGE_NAME, <span class="string">"key.*"</span>);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;MQ&quot;&gt;&lt;a href=&quot;#MQ&quot; class=&quot;headerlink&quot; title=&quot;MQ&quot;&gt;&lt;/a&gt;MQ&lt;/h3&gt;&lt;p&gt;Message Queue&lt;br&gt;AMQP基础 Advanced Message Queuing Protocol&lt;br&gt;产品: ActiveMQ(Apache), Kafka&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="RabbitMQ" scheme="https://www.jpan.ink/categories/RabbitMQ/"/>
    
    
      <category term="Message-middleware" scheme="https://www.jpan.ink/tags/Message-middleware/"/>
    
  </entry>
  
  <entry>
    <title>Redis</title>
    <link href="https://www.jpan.ink/2019/01/20/Redis-note/"/>
    <id>https://www.jpan.ink/2019/01/20/Redis-note/</id>
    <published>2019-01-19T16:00:00.000Z</published>
    <updated>2019-03-28T15:10:09.240Z</updated>
    
    <content type="html"><![CDATA[<h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h3><ul><li>字符类型</li><li>散列类型</li><li>列表类型</li><li>集合类型</li><li>有序集合</li><li>bitMap （登陆)</li></ul><h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><ul><li>缓存</li><li>设置超时时间</li><li>实现分布式队列的操作</li><li>支持发布订阅的消息模式</li></ul><h2 id="Redis命令"><a href="#Redis命令" class="headerlink" title="Redis命令"></a>Redis命令</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">./redis-server ../redis.conf</span><br><span class="line">./redis-cli shutdown</span><br><span class="line">以后台进程的方式启动，修改redis.conf   daemonize =yes</span><br><span class="line"> </span><br><span class="line">连接到redis的命令</span><br><span class="line"> ./redis-cli -h 127.0.0.1 -p 6379</span><br><span class="line"></span><br><span class="line">Redis-server 启动服务</span><br><span class="line">Redis-cli 访问到redis的控制台</span><br><span class="line">redis-benchmark 性能测试的工具</span><br><span class="line">redis-<span class="keyword">check</span>-aof aof文件进行检测的工具</span><br><span class="line">redis-<span class="keyword">check</span>-dump  rdb文件检查工具</span><br><span class="line">redis-sentinel  sentinel 服务器配置</span><br><span class="line"></span><br><span class="line"># 获得一个符合匹配规则的键名列表</span><br><span class="line"><span class="keyword">keys</span> pattern  [? / * /[]]</span><br><span class="line"><span class="keyword">EXISTS</span> <span class="keyword">key</span></span><br><span class="line"><span class="keyword">type</span> <span class="keyword">key</span></span><br><span class="line">incr <span class="keyword">key</span></span><br><span class="line">incryby <span class="keyword">key</span> <span class="keyword">increment</span>  递增指定的整数</span><br><span class="line">decr <span class="keyword">key</span>   原子递减</span><br><span class="line">append <span class="keyword">key</span> <span class="keyword">value</span>   向指定的<span class="keyword">key</span>追加字符串</span><br><span class="line">strlen  <span class="keyword">key</span>  获得<span class="keyword">key</span>对应的<span class="keyword">value</span>的长度</span><br><span class="line">mget  <span class="keyword">key</span> key..  同时获得多个<span class="keyword">key</span>的<span class="keyword">value</span></span><br><span class="line">mset <span class="keyword">key</span> <span class="keyword">value</span>  <span class="keyword">key</span> <span class="keyword">value</span>  <span class="keyword">key</span> <span class="keyword">value</span> …</span><br><span class="line">llen <span class="keyword">num</span>  获得列表的长度</span><br><span class="line">lrange <span class="keyword">key</span>  <span class="keyword">start</span> <span class="keyword">stop</span>   ;  索引可以是负数， -1表示最右边的第一个元素</span><br><span class="line">lrem key count value</span><br><span class="line">lset key index value</span><br><span class="line">LPOP/RPOP : 取数据</span><br><span class="line">应用场景：可以用来做分布式消息队列</span><br><span class="line">.....</span><br></pre></td></tr></table></figure><h3 id="redis的事务处理"><a href="#redis的事务处理" class="headerlink" title="redis的事务处理"></a>redis的事务处理</h3><ul><li>MULTI 去开启事务</li><li>EXEC 去执行事务</li></ul><h3 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h3><p>数据库，通过唯一约束</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">lock(</span><br><span class="line">  id  int(<span class="number">11</span>)</span><br><span class="line">  methodName  varchar(<span class="number">100</span>),</span><br><span class="line">  memo varchar(<span class="number">1000</span>)</span><br><span class="line">  modifyTime timestamp</span><br><span class="line">  unique key mn (<span class="function"><span class="keyword">method</span>)  --唯一约束</span></span><br><span class="line"><span class="function">)</span></span><br></pre></td></tr></table></figure><p>获取锁的伪代码</p><figure class="highlight monkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"> exec insert into lock(methodName,memo) values(‘<span class="function"><span class="keyword">method</span>’,’<span class="title">desc</span>’);</span></span><br><span class="line"> <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;<span class="keyword">Catch</span>(DuplicateException e)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>释放锁<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> <span class="keyword">lock</span> <span class="keyword">where</span> methodName=’’;</span><br></pre></td></tr></table></figure></p><h3 id="redis-setNx"><a href="#redis-setNx" class="headerlink" title="redis setNx"></a>redis setNx</h3><ul><li>jedis集成了redis的一些命令操作</li><li>spring 封装的 redis —— Spring Data Redis</li></ul><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(jedis.setNx(<span class="built_in">key</span>,value) == <span class="number">1</span>)&#123;</span><br><span class="line">jedis.expire(<span class="built_in">key</span>,<span class="built_in">time</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Transaction t = jedis.multi();</span><br><span class="line">t.<span class="built_in">del</span>(<span class="built_in">key</span>)</span><br></pre></td></tr></table></figure><h3 id="lua脚本"><a href="#lua脚本" class="headerlink" title="lua脚本"></a>lua脚本</h3><p>Lua是一个高效的轻量级脚本语言，用标准C语言编写并以源代码形式开放， 其设计目的是为了嵌入应用程序中，从而为应用程序提供灵活的扩展和定制功能</p><ul><li>redis.call(‘set’,’hello’,’world’)</li><li>Redis提供了EVAL命令可以使开发者像调用其他Redis内置命令一样调用脚本。</li><li>[EVAL]  [脚本内容] [key参数的数量]  [key …] [arg …]</li></ul><h3 id="redis持久化机制"><a href="#redis持久化机制" class="headerlink" title="redis持久化机制"></a>redis持久化机制</h3><ul><li>RDB的持久化策略： 按照规则定时讲内从的数据同步到磁盘</li><li><p>AOF可以将Redis执行的每一条写命令追加到硬盘文件中</p></li><li><p>一般来说,如果对数据的安全性要求非常高的话，应该同时使用两种持久化功能。</p></li><li>如果可以承受数分钟以内的数据丢失，那么可以只使用 RDB 持久化。因为定时生成 RDB 快照（snapshot）非常便于进行数据库备份， 并且 RDB 恢复数据集的速度也要比 AOF 恢复的速度要快 。</li></ul><h3 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h3><p>复制（master、slave）</p><h4 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h4><ul><li>slave第一次或者重连到master上以后，会向master发送一个SYNC的命令</li><li>master收到SYNC的时候，会做两件事<ol><li>执行bgsave（rdb的快照文件）</li><li>master会把新收到的修改命令存入到缓冲区</li></ol></li></ul><h4 id="哨兵机制"><a href="#哨兵机制" class="headerlink" title="哨兵机制"></a>哨兵机制</h4><ul><li>监控 master和salve是否正常运行</li><li>如果master出现故障，那么会把其中一台salve数据升级为master</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;类型&quot;&gt;&lt;a href=&quot;#类型&quot; class=&quot;headerlink&quot; title=&quot;类型&quot;&gt;&lt;/a&gt;类型&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;字符类型&lt;/li&gt;
&lt;li&gt;散列类型&lt;/li&gt;
&lt;li&gt;列表类型&lt;/li&gt;
&lt;li&gt;集合类型&lt;/li&gt;
&lt;li&gt;有序集合&lt;/li
      
    
    </summary>
    
      <category term="Redis" scheme="https://www.jpan.ink/categories/Redis/"/>
    
    
      <category term="Distributed" scheme="https://www.jpan.ink/tags/Distributed/"/>
    
  </entry>
  
  <entry>
    <title>Session单点登录</title>
    <link href="https://www.jpan.ink/2018/12/06/Session-login/"/>
    <id>https://www.jpan.ink/2018/12/06/Session-login/</id>
    <published>2018-12-05T16:00:00.000Z</published>
    <updated>2019-03-28T15:12:50.087Z</updated>
    
    <content type="html"><![CDATA[<h3 id="http协议是无状态的"><a href="#http协议是无状态的" class="headerlink" title="http协议是无状态的"></a>http协议是无状态的</h3><ul><li>使用动态信息会使网站更丰富 html/css/js  jspsevelet/cgi</li><li>cookie 容器对象session解决了http无状态的问题</li></ul><h3 id="关于cookie"><a href="#关于cookie" class="headerlink" title="关于cookie"></a>关于cookie</h3><ul><li>cookie中包含：名字 值 过期时间 路径 域</li><li>cookie会带到http请求头中发送给服务器端</li><li>如果cookie没有设置过期时间的话，cookie的默认生命周期是浏览器的会话</li><li>如果过期时间&gt;浏览器的会话，则会存在磁盘中</li></ul><h3 id="session机制"><a href="#session机制" class="headerlink" title="session机制"></a>session机制</h3><ul><li>session是容器对象，客户端在请求服务端的时候，服务端会根据客户端的请求判断是否包含了sessionid的标识<br>如果已经包含，说明之前已经建立了会话，sessionid是唯一的</li><li>如果sessionid不存在，那么服务端会为这个客户端生成一个sessionid JSESSIONID</li></ul><h3 id="攻击"><a href="#攻击" class="headerlink" title="攻击"></a>攻击</h3><p>ssl攻击 xss攻击 重放攻击等</p><h3 id="session共享问题"><a href="#session共享问题" class="headerlink" title="session共享问题"></a>session共享问题</h3><ol><li><p>session复制 ，中间件同步</p><ul><li>问题： 性能开销，数据冗余</li></ul></li><li><p>持久化session数据</p><ul><li>数据库或者缓存（redis）</li><li>实现简单，对客户端是透明的</li><li>重写了tomcat会话生成机制，不存在内存里</li></ul></li><li><p>基于cookie机制</p><ul><li>APP里面生成token token写入浏览器cookie token带到服务端来</li></ul></li><li><p>基于JWT的解决方案</p><ul><li>Json Web Token</li><li>客户端和服务端信息安全传递以及身份认证的解决方案；用在登录上</li></ul></li></ol><p>Jwt的组成</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">header</span>、<span class="selector-tag">payload</span>、<span class="selector-tag">signature</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="attribute">typ</span>:<span class="string">"jwt"</span>,</span><br><span class="line">alg:<span class="string">"HS256"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>payload base64编码<br>jwt本身规范提供的格式<br>iss，iat，exp，sub，claims，自己定义一些</p><p>signature</p><p>signature<br>header+payload组成一个字符串<br>Base64(header).Base64(payload)</p><p>JWT的token<br>str.签名字符串</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;http协议是无状态的&quot;&gt;&lt;a href=&quot;#http协议是无状态的&quot; class=&quot;headerlink&quot; title=&quot;http协议是无状态的&quot;&gt;&lt;/a&gt;http协议是无状态的&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;使用动态信息会使网站更丰富 html/css/js  j
      
    
    </summary>
    
      <category term="Session" scheme="https://www.jpan.ink/categories/Session/"/>
    
    
      <category term="Distributed" scheme="https://www.jpan.ink/tags/Distributed/"/>
    
  </entry>
  
  <entry>
    <title>排序算法</title>
    <link href="https://www.jpan.ink/2018/11/20/Algorithm-sorting/"/>
    <id>https://www.jpan.ink/2018/11/20/Algorithm-sorting/</id>
    <published>2018-11-19T16:00:00.000Z</published>
    <updated>2019-03-24T15:14:48.410Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>时间复杂度 big 0<br>空间复杂度 </p><p>判断算法的好坏：<br>先看时间复杂度，在分析实际运行时间（常数项时间）<br>稳定的算法：<br>长期期望就是复杂度，和最长最短没关系，也不影响稳定性<br>稳定性:<br>排序中相同的值原始的相对次序不变</p><h4 id="对数器"><a href="#对数器" class="headerlink" title="对数器"></a>对数器</h4><p>绝对正确的方法a<br>随机样本产生器<br>比对多次</p><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p><img src="/2018/11/20/Algorithm-sorting/1.png" alt=""></p><ul><li>快速排序 经典快速排序（取最后一个值）</li><li>递归排序 工程上快排不用递归 所有递归算法都可以改成非递归<br>递归函数的代价很大 常数时间很大（系统压栈）<br>系统栈 多层后会报错 不安全</li><li>堆排序<br>完全二叉树（满二叉树 或者 依次补齐） 左孩子2i+1 右孩子 2i+2 0的父节点是0 完全二叉树 = 堆 = 数组结构<br>大根堆 = 任何树的最大值是头部  小根堆<br>建立大根堆 o（n）  heapInsert heapify<br>堆也适用 heap，treeSet 红黑树</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>工程上使用排序</p><ul><li>基础类型 快速排序  </li><li>对象类型 归并排序</li><li>稳定性 很短的数组（长度小于60） 插入排序（常数项很低）</li></ul><h3 id="master公式的使用："><a href="#master公式的使用：" class="headerlink" title="master公式的使用："></a>master公式的使用：</h3><p>T（N）= a*T(N/b) + O(n^d)</p><p>其中N为行为的总样本量，N/b为子行为的样本量，a为子行为发生的次数，除了调用子过程之外进行剩下的操作的所花费的时间代价。</p><pre><code>T(N) = a*T(N/b) + O(N^d)1) log(b,a) &gt; d -&gt; 复杂度为O(N^log(b,a))2) log(b,a) = d -&gt; 复杂度为O(N^d * logN)3) log(b,a) &lt; d -&gt; 复杂度为O(N^d)  </code></pre><h3 id="java自定义排序"><a href="#java自定义排序" class="headerlink" title="java自定义排序"></a>java自定义排序</h3><p>Arrays.sort()<br>如果没有定义 基础类型按照值从小到大排序 对象内存地址排序<br>Arrays.sort(list，new SpecialComparator)；</p><p>new PriortyQueue&lt;&gt;(new SpecialComparator());</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h3&gt;&lt;p&gt;时间复杂度 big 0&lt;br&gt;空间复杂度 &lt;/p&gt;
&lt;p&gt;判断算法的好坏：&lt;br&gt;先看时间复杂度，在分析实际运行时间（常数项时间）&lt;br&gt;稳
      
    
    </summary>
    
      <category term="Algorithm" scheme="https://www.jpan.ink/categories/Algorithm/"/>
    
    
      <category term="Algorithm" scheme="https://www.jpan.ink/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>JVM原理</title>
    <link href="https://www.jpan.ink/2018/10/29/Java-jvm/"/>
    <id>https://www.jpan.ink/2018/10/29/Java-jvm/</id>
    <published>2018-10-28T16:00:00.000Z</published>
    <updated>2019-03-28T15:16:14.910Z</updated>
    
    <content type="html"><![CDATA[<h3 id="JVM运行时数据区"><a href="#JVM运行时数据区" class="headerlink" title="JVM运行时数据区"></a>JVM运行时数据区</h3><h4 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h4><p>只想当前线程正在执行的字节码指令的地址 行号</p><h4 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h4><p>存储当前线程运行方法所需要的数据（局部变量，动态链接），指令和返回地址</p><h4 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈:"></a>本地方法栈:</h4><ul><li>存放基本类型的变量数据和对象的引用，</li><li>对象本身在堆中或者常量池中<h4 id="方法区"><a href="#方法区" class="headerlink" title="方法区:"></a>方法区:</h4></li></ul><ol><li>又叫静态区，跟堆一样，被所有的线程共享。方法区包含类信息、常量、静态变量、JIT（just in time 类的源信息 版本号之类的）</li><li>常量池：存放基本类型常量和字符串常量。字面量，符号引用 类，接口，方法名称和描述符，引用的方法。方法区中存储着class文件和动态常量池。</li><li>class文件常量池又分为类信息和静态常量池，包括字符串，基本类型变量和符号引用。</li><li>动态又叫运行时常量池，class文件加载完后，虚拟机会将一部分静态常量池的内容转移到动态常量池里，符号引用一部分变成直接引用，比如说类的静态/私有方法。其他的会在第一次使用变成直接引用。</li><li>动态常量池的内容能够动态添加，比如String的intern方法。 运行时多态</li><li>jdk1.8后，将Stirng常量池放到了堆中。<ul><li>只有被final修饰的基本数据类型和String类型变量在编译时才会被确定下来，因此存放在常量池中。</li><li>而对于int a=1，数据是存在栈中的，因为这个值并不是常量（区别于常量的定义）</li><li>字符串符号引用的其实就是常量池的字符串，但是存储的是字符串在常量池的索引</li></ul></li></ol><h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><ul><li>程序计数器、虚拟机栈、本地方法栈3个区域随线程而生、随线程而灭。方法结束或者线程结束时，内存自然就跟随着回收了。</li><li>Java堆区和方法区这部分内存的分配和回收是动态的，正是垃圾收集器所需关注的部分。</li></ul><h3 id="JVM内存模型"><a href="#JVM内存模型" class="headerlink" title="JVM内存模型"></a>JVM内存模型</h3><p>1.7新生代 老年代 永久代在堆里面<br>1.8 去掉了永久代 加上了Meta Space，在内存里面</p><h4 id="新生代"><a href="#新生代" class="headerlink" title="新生代"></a>新生代</h4><ul><li>复制回收算法 8：1：1</li><li>98%对象会在minor gc的时候被回收掉</li><li>对象的生命周期不一样 分代算法</li><li>分配担保  </li><li>新生代：老年代 = 1：2</li></ul><h4 id="老年代"><a href="#老年代" class="headerlink" title="老年代"></a>老年代</h4><ul><li>标记清除 /标记整理</li></ul><h4 id="什么样的对象需要被gc-判断算法"><a href="#什么样的对象需要被gc-判断算法" class="headerlink" title="什么样的对象需要被gc | 判断算法"></a>什么样的对象需要被gc | 判断算法</h4><ul><li>引用计数法 <ul><li>循环引用</li></ul></li><li>可达性分析<ul><li>gc root<ul><li>虚拟机栈中本地变量表引用的对象</li><li>方法区中<ul><li>常量引用的对象</li><li>类静态变量应用的对象</li></ul></li><li>本地方法栈中JNI引用对象</li></ul></li></ul></li><li>不可达不一定被回收<ul><li>finalize()</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      JVM内存模型和gc判断
    
    </summary>
    
      <category term="JVM" scheme="https://www.jpan.ink/categories/JVM/"/>
    
    
      <category term="Java" scheme="https://www.jpan.ink/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>地址和值</title>
    <link href="https://www.jpan.ink/2018/03/29/Java-equal/"/>
    <id>https://www.jpan.ink/2018/03/29/Java-equal/</id>
    <published>2018-03-29T02:28:40.000Z</published>
    <updated>2019-03-28T15:26:24.702Z</updated>
    
    <content type="html"><![CDATA[<h3 id="和-equal"><a href="#和-equal" class="headerlink" title="== 和 equal"></a>== 和 equal</h3><ul><li>== 对比基本数据类型的值和引用对象的内存地址</li><li>equal 判断两个对象是否相等，需要重写equals()方法，否则是判断两个对象是否指向一个对象。</li></ul><h3 id="equal"><a href="#equal" class="headerlink" title="equal"></a>equal</h3><p>Object的equal方法，定义原型如下：</p><pre><code>public boolean equals (Object x){    return this == x;}</code></pre><h3 id="相等与同一"><a href="#相等与同一" class="headerlink" title="相等与同一"></a>相等与同一</h3><ul><li>如果两个对象具有相同的类型以及相同的属性值，则称这两个对象相等。</li><li>如果两个引用对象指的是同一个对像，则称这两个变量同一。</li></ul><h3 id="深拷贝和浅拷贝"><a href="#深拷贝和浅拷贝" class="headerlink" title="深拷贝和浅拷贝"></a>深拷贝和浅拷贝</h3><ul><li>深拷贝会把引用的内容一起拷贝过来</li></ul><h3 id="String的存储"><a href="#String的存储" class="headerlink" title="String的存储"></a>String的存储</h3><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>. <span class="keyword">String </span><span class="keyword">str1 </span>= <span class="string">"abc"</span><span class="comment">; </span></span><br><span class="line">  System.out.println(<span class="keyword">str1 </span>== <span class="string">"abc"</span>)<span class="comment">; </span></span><br><span class="line"></span><br><span class="line">步骤： </span><br><span class="line"><span class="number">1</span>) 栈中开辟一块空间存放引用<span class="keyword">str1， </span></span><br><span class="line"><span class="number">2</span>) <span class="keyword">String池中开辟一块空间，存放String常量"abc"， </span></span><br><span class="line"><span class="number">3</span>) 引用<span class="keyword">str1指向池中String常量"abc"， </span></span><br><span class="line"><span class="number">4</span>) <span class="keyword">str1所指代的地址即常量"abc"所在地址，输出为true </span></span><br><span class="line"></span><br><span class="line"><span class="number">2</span>. <span class="keyword">String </span><span class="keyword">str2 </span>= new <span class="keyword">String("abc"); </span></span><br><span class="line">  System.out.println(<span class="keyword">str2 </span>== <span class="string">"abc"</span>)<span class="comment">; </span></span><br><span class="line"></span><br><span class="line">步骤： </span><br><span class="line"><span class="number">1</span>) 栈中开辟一块空间存放引用<span class="keyword">str2， </span></span><br><span class="line"><span class="number">2</span>) 堆中开辟一块空间存放一个新建的<span class="keyword">String对象"abc"， </span></span><br><span class="line"><span class="number">3</span>) 引用<span class="keyword">str2指向堆中的新建的String对象"abc"， </span></span><br><span class="line"><span class="number">4</span>) <span class="keyword">str2所指代的对象地址为堆中地址，而常量"abc"地址在池中，输出为false </span></span><br><span class="line"></span><br><span class="line"><span class="number">3</span>. <span class="keyword">String </span><span class="keyword">str3 </span>= new <span class="keyword">String（"abc"); </span></span><br><span class="line">  System.out.println(<span class="keyword">str3 </span>== <span class="keyword">str2); </span></span><br><span class="line"></span><br><span class="line">步骤： </span><br><span class="line"><span class="number">1</span>) 栈中开辟一块空间存放引用<span class="keyword">str3， </span></span><br><span class="line"><span class="number">2</span>) 堆中开辟一块新空间存放另外一个(不同于<span class="keyword">str2所指)新建的String对象， </span></span><br><span class="line"><span class="number">3</span>) 引用<span class="keyword">str3指向另外新建的那个String对象 </span></span><br><span class="line"><span class="number">4</span>) <span class="keyword">str3和str2指向堆中不同的String对象，地址也不相同，输出为false </span></span><br><span class="line"></span><br><span class="line"><span class="number">4</span>. <span class="keyword">String </span><span class="keyword">str4 </span>= <span class="string">"a"</span> + <span class="string">"b"</span><span class="comment">; </span></span><br><span class="line">  System.out.println(<span class="keyword">str4 </span>== <span class="string">"ab"</span>)<span class="comment">; </span></span><br><span class="line"></span><br><span class="line">步骤： </span><br><span class="line"><span class="number">1</span>) 栈中开辟一块空间存放引用<span class="keyword">str4， </span></span><br><span class="line"><span class="number">2</span>) 根据编译器合并已知量的优化功能，池中开辟一块空间，存放合并后的<span class="keyword">String常量"ab"， </span></span><br><span class="line"><span class="number">3</span>) 引用<span class="keyword">str4指向池中常量"ab"， </span></span><br><span class="line"><span class="number">4</span>) <span class="keyword">str4所指即池中常量"ab"，输出为true </span></span><br><span class="line"></span><br><span class="line"><span class="number">5</span>. final <span class="keyword">String </span>s = <span class="string">"a"</span><span class="comment">; </span></span><br><span class="line">  <span class="keyword">String </span><span class="keyword">str5 </span>= s + <span class="string">"b"</span><span class="comment">; </span></span><br><span class="line">  System.out.println(<span class="keyword">str5 </span>== <span class="string">"ab"</span>)<span class="comment">; </span></span><br><span class="line"></span><br><span class="line">步骤： </span><br><span class="line">同<span class="number">4</span> </span><br><span class="line"></span><br><span class="line"><span class="number">6</span>. <span class="keyword">String </span><span class="built_in">s1</span> = <span class="string">"a"</span><span class="comment">; </span></span><br><span class="line">  <span class="keyword">String </span><span class="built_in">s2</span> = <span class="string">"b"</span><span class="comment">; </span></span><br><span class="line">  <span class="keyword">String </span><span class="keyword">str6 </span>= <span class="built_in">s1</span> + <span class="built_in">s2</span><span class="comment">; </span></span><br><span class="line">  System.out.println(<span class="keyword">str6 </span>== <span class="string">"ab"</span>)<span class="comment">; </span></span><br><span class="line"></span><br><span class="line">步骤： </span><br><span class="line"><span class="number">1</span>) 栈中开辟一块中间存放引用<span class="built_in">s1</span>，<span class="built_in">s1</span>指向池中<span class="keyword">String常量"a"， </span></span><br><span class="line"><span class="number">2</span>) 栈中开辟一块中间存放引用<span class="built_in">s2</span>，<span class="built_in">s2</span>指向池中<span class="keyword">String常量"b"， </span></span><br><span class="line"><span class="number">3</span>) 栈中开辟一块中间存放引用<span class="keyword">str5， </span></span><br><span class="line"><span class="number">4</span>) <span class="built_in">s1</span> + <span class="built_in">s2</span>通过<span class="keyword">StringBuilder的最后一步toString()方法还原一个新的String对象"ab"，因此堆中开辟一块空间存放此对象， </span></span><br><span class="line"><span class="number">5</span>) 引用<span class="keyword">str6指向堆中(s1 </span>+ <span class="built_in">s2</span>)所还原的新<span class="keyword">String对象， </span></span><br><span class="line"><span class="number">6</span>) <span class="keyword">str6指向的对象在堆中，而常量"ab"在池中，输出为false </span></span><br><span class="line"></span><br><span class="line"><span class="number">7</span>. <span class="keyword">String </span><span class="keyword">str7 </span>= <span class="string">"abc"</span>.<span class="keyword">substring(0, </span><span class="number">2</span>)<span class="comment">; </span></span><br><span class="line"></span><br><span class="line">步骤： </span><br><span class="line"><span class="number">1</span>) 栈中开辟一块空间存放引用<span class="keyword">str7， </span></span><br><span class="line"><span class="number">2</span>) <span class="keyword">substring()方法还原一个新的String对象"ab"（不同于str6所指），堆中开辟一块空间存放此对象， </span></span><br><span class="line"><span class="number">3</span>) 引用<span class="keyword">str7指向堆中的新String对象， </span></span><br><span class="line"></span><br><span class="line"><span class="number">8</span>. <span class="keyword">String </span><span class="keyword">str8 </span>= <span class="string">"abc"</span>.toUpperCase()<span class="comment">; </span></span><br><span class="line"></span><br><span class="line">步骤： </span><br><span class="line"><span class="number">1</span>) 栈中开辟一块空间存放引用<span class="keyword">str6， </span></span><br><span class="line"><span class="number">2</span>) toUpperCase()方法还原一个新的<span class="keyword">String对象"ABC"，池中并未开辟新的空间存放String常量"ABC"， </span></span><br><span class="line"><span class="number">3</span>) 引用<span class="keyword">str8指向堆中的新String对象</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;和-equal&quot;&gt;&lt;a href=&quot;#和-equal&quot; class=&quot;headerlink&quot; title=&quot;== 和 equal&quot;&gt;&lt;/a&gt;== 和 equal&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;== 对比基本数据类型的值和引用对象的内存地址&lt;/li&gt;
&lt;li&gt;equal
      
    
    </summary>
    
      <category term="Java" scheme="https://www.jpan.ink/categories/Java/"/>
    
      <category term="String" scheme="https://www.jpan.ink/categories/String/"/>
    
    
      <category term="Java" scheme="https://www.jpan.ink/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>First Paper Note</title>
    <link href="https://www.jpan.ink/2018/03/25/My-daily-record/"/>
    <id>https://www.jpan.ink/2018/03/25/My-daily-record/</id>
    <published>2018-03-25T09:13:33.000Z</published>
    <updated>2019-03-27T15:05:37.060Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="http://www.jpan.ink">jpan</a>!</p><p><img src="https://i.imgur.com/tiJmhCw.jpg" alt=""></p><p>2018年1月3日开始动手做博客</p><p>2018年3月20日博客有了背景 接着有了自己的链接</p><p>2018年4月25日发布第一篇博文</p><p>2019年3月17日将一些笔记录入博客</p>]]></content>
    
    <summary type="html">
    
      notes
    
    </summary>
    
      <category term="Notes" scheme="https://www.jpan.ink/categories/Notes/"/>
    
    
      <category term="Notes" scheme="https://www.jpan.ink/tags/Notes/"/>
    
  </entry>
  
  <entry>
    <title>idea快捷键操作</title>
    <link href="https://www.jpan.ink/2018/01/11/Intellij-idea-control/"/>
    <id>https://www.jpan.ink/2018/01/11/Intellij-idea-control/</id>
    <published>2018-01-10T16:00:00.000Z</published>
    <updated>2019-03-17T15:48:32.208Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/** 回车 注释</span><br><span class="line">alt insert 插入 或者alt+<span class="regexp">/  插入重写函数</span></span><br><span class="line"><span class="regexp">alt enter自动填充</span></span><br><span class="line"><span class="regexp">shift f6重构</span></span><br><span class="line"><span class="regexp">null json会自动忽视</span></span><br><span class="line"><span class="regexp">Alt Tab切换当前窗口</span></span><br><span class="line"><span class="regexp">sout tap</span></span><br><span class="line"><span class="regexp">Alt+home 回到编辑栏</span></span><br><span class="line"><span class="regexp">Shift+Shift查找文件   Ctrl+n查找类</span></span><br><span class="line"><span class="regexp">Ctrl+g 定位行</span></span><br><span class="line"><span class="regexp">Ctrl+r  替换当前页面   Ctrl +f搜索当前页面</span></span><br><span class="line"><span class="regexp">Ctrl+e 最近打开的文件</span></span><br><span class="line"><span class="regexp">Ctrl +F8 断点</span></span><br><span class="line"><span class="regexp">F7 步入</span></span><br><span class="line"><span class="regexp">Ctrl + +/</span>-折叠展开</span><br><span class="line">Ctrl [<span class="regexp">/] 当前位置的括号开始</span></span><br><span class="line"><span class="regexp">Ctrl  F4 关闭当前编辑文件</span></span><br><span class="line"><span class="regexp">Ctrl F12选择当前文件的方法</span></span><br><span class="line"><span class="regexp">Ctrl Home/</span>End 跳到文件头、末尾</span><br><span class="line">Ctrl Y 删除选择行</span><br><span class="line">Ctrl W 递进式选择代码块</span><br><span class="line">Ctrl 方向键 鼠标滚轮效果</span><br><span class="line">Alt 方向键 切换页面</span><br><span class="line">Ctrl+Shift +J自动将该行合并到末尾  切空行必备</span><br></pre></td></tr></table></figure><p>2018/2/9新增</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">alt+<span class="number">1</span> 跳转光标至project框 end返回到编辑栏</span><br><span class="line">alt+ctrl+&#123; 跳转idea</span><br><span class="line">ctrl +E 最近文件</span><br><span class="line"><span class="keyword">shift </span>+ctrl +<span class="keyword">backspace </span>上次编辑位置</span><br><span class="line">F11 书签 ctrl+F1有标记的书签   ctrl+<span class="number">1</span>跳到标记书签<span class="number">1</span></span><br><span class="line"><span class="keyword">shift+ctrl+向上箭头 </span> 两行换方向</span><br><span class="line"><span class="keyword">shift+ctrl+u </span>大小写转换</span><br><span class="line">F2 错误跳转</span><br><span class="line">alt+enter 提示 <span class="number">1</span>、自动创建函数</span><br><span class="line"><span class="keyword">shift </span>+F6重构</span><br><span class="line">alt+ctrl+p 抽取一段代码作为传值传进来</span><br><span class="line">alt+ctrl+m  抽取一段代码独立成方法</span><br><span class="line"><span class="keyword">shift+clt+F8条件断点</span></span><br><span class="line"><span class="keyword">F2修改断点的值</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">自定义</span></span><br><span class="line"><span class="keyword">live </span>template</span><br><span class="line">.sout</span><br><span class="line"><span class="number">100</span>.fori</span><br><span class="line">XXX.field   在构筑函数中用 可以初始化和定义</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight crystal&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span cla
      
    
    </summary>
    
      <category term="Intellij idea" scheme="https://www.jpan.ink/categories/Intellij-idea/"/>
    
    
      <category term="Tool" scheme="https://www.jpan.ink/tags/Tool/"/>
    
  </entry>
  
  <entry>
    <title>Beautiful Soup</title>
    <link href="https://www.jpan.ink/2017/05/08/Beautiful-soup/"/>
    <id>https://www.jpan.ink/2017/05/08/Beautiful-soup/</id>
    <published>2017-05-07T16:00:00.000Z</published>
    <updated>2019-03-17T15:40:38.823Z</updated>
    
    <content type="html"><![CDATA[<p>Beautiful Soup</p><ul><li>提供一些简单的、python式的函数用来处理导航、搜索、修改分析树等功能。它是一个工具箱，通过解析文档为用户提供需要抓取的数据，因为简单，所以不需要多少代码就可以写出一个完整的应用程序。</li><li>自动将输入文档转换为Unicode编码，输出文档转换为utf-8编码。你不需要考虑编码方式，除非文档没有指定一个编码方式，这时，Beautiful Soup就不能自动识别编码方式了。然后，你仅仅需要说明一下原始编码方式就可以了。</li><li>已成为和lxml、html6lib一样出色的python解释器，为用户灵活地提供不同的解析策略或强劲的速度。</li></ul><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">soup = BeautifulSoup(<span class="keyword">open</span>(<span class="string">'index.html'</span>))</span><br><span class="line"><span class="keyword">print</span> soup.prettify()</span><br><span class="line"><span class="keyword">print</span> soup.head  </span><br><span class="line"><span class="comment">#&lt;head&gt;&lt;title&gt;The Dormouse's story&lt;/title&gt;&lt;/head&gt;</span></span><br><span class="line"><span class="keyword">print</span> soup.p.string <span class="comment"># 标签内部的文字</span></span><br></pre></td></tr></table></figure><p>Tag有两个重要的属性，是 name 和 attrs</p><pre><code>p.attrs  #{&apos;class&apos;: [&apos;title&apos;], &apos;name&apos;: &apos;dromouse&apos;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Beautiful Soup&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;提供一些简单的、python式的函数用来处理导航、搜索、修改分析树等功能。它是一个工具箱，通过解析文档为用户提供需要抓取的数据，因为简单，所以不需要多少代码就可以写出一个完整的应用程序。&lt;/li&gt;
&lt;li&gt;自动将输入文
      
    
    </summary>
    
      <category term="Beautiful Soup" scheme="https://www.jpan.ink/categories/Beautiful-Soup/"/>
    
    
      <category term="Web" scheme="https://www.jpan.ink/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>json与list的转换</title>
    <link href="https://www.jpan.ink/2017/03/29/Json-convert-to-list/"/>
    <id>https://www.jpan.ink/2017/03/29/Json-convert-to-list/</id>
    <published>2017-03-29T02:28:40.000Z</published>
    <updated>2019-03-28T15:28:17.521Z</updated>
    
    <content type="html"><![CDATA[<h3 id="当不通过form-data进行传送数据时"><a href="#当不通过form-data进行传送数据时" class="headerlink" title="当不通过form-data进行传送数据时"></a>当不通过form-data进行传送数据时</h3><h4 id="无法直接传json的list-可以通过转换为String传送"><a href="#无法直接传json的list-可以通过转换为String传送" class="headerlink" title="无法直接传json的list 可以通过转换为String传送"></a>无法直接传json的list 可以通过转换为String传送</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">contentStr = <span class="built_in">JSON</span>.stringify(list),</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object content = JSONArray.parseArray(contentStr, Object.class)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;当不通过form-data进行传送数据时&quot;&gt;&lt;a href=&quot;#当不通过form-data进行传送数据时&quot; class=&quot;headerlink&quot; title=&quot;当不通过form-data进行传送数据时&quot;&gt;&lt;/a&gt;当不通过form-data进行传送数据时&lt;/h3&gt;&lt;
      
    
    </summary>
    
      <category term="Json" scheme="https://www.jpan.ink/categories/Json/"/>
    
      <category term="JS" scheme="https://www.jpan.ink/categories/JS/"/>
    
    
      <category term="Web" scheme="https://www.jpan.ink/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>CleanCode-note</title>
    <link href="https://www.jpan.ink/2017/03/14/CleanCode-note/"/>
    <id>https://www.jpan.ink/2017/03/14/CleanCode-note/</id>
    <published>2017-03-14T13:44:06.000Z</published>
    <updated>2019-03-17T14:33:36.340Z</updated>
    
    <content type="html"><![CDATA[<p>###前五章</p><ul><li>减少抽象代码 提高表达力 提早构建简单抽象代码</li></ul><h4 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h4><ul><li>避免使用意义相悖的命名 避免使用相似易误解的命名</li><li>避免使用没有意义的命名</li><li>使用可搜索的名称 即在全局中不要出现太多</li><li>避免除循环外的单字母命名</li><li>类名是名词，方法名是动词</li><li>函数名称应该独一无二，且保持一致</li></ul><h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><ul><li><p>if语句 else语句 while语句代码块应该只有一行</p></li><li><p>函数应该只做一件事    每个函数只有一个抽象层级</p></li><li>函数参数尽量避免三个及以上；  避免信息通过参数输出</li><li>标志参数不要传布尔值</li><li>避免使用用参数做输出的函数 或者这样做  get_fied(report)改成 report.get_fied()</li><li>函数要么做什么事，要么回答什么事，二者不可兼得，最好不要做什么事再返回成功了没有。</li><li>返回错误码轻微的违反了规则，可以用try /catch 来处理错误</li><li>错误处理就是函数的一件事，应该就是函数的主体，try和finally前面后面都不该有东西</li></ul><h4 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h4><ul><li>有时间写大量注释，不如优化代码</li><li>代码能够阐述含义</li><li>唯一真正好的注释是想办法不写注释</li><li>值得写注释的  法律信息，对意图的结束 ，警告，认为应该写而没有写的东西</li></ul><p>####格式</p><ul><li>单个java文件应该在200~400行之间</li><li>垂直方向 紧密联系的代码应该互相靠近</li><li>概念上垂直方向上间隔记得要空格</li><li>变量声明应尽可能靠近其使用位置</li><li>变量声明应该在类的顶部声明</li></ul><h4 id="通过目录来回忆"><a href="#通过目录来回忆" class="headerlink" title="通过目录来回忆"></a>通过目录来回忆</h4><p><img src="/2017/03/14/CleanCode-note/1.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      reading notes
    
    </summary>
    
      <category term="Clean-code" scheme="https://www.jpan.ink/categories/Clean-code/"/>
    
    
      <category term="Notes" scheme="https://www.jpan.ink/tags/Notes/"/>
    
  </entry>
  
  <entry>
    <title>在Python2.7中和编码作战</title>
    <link href="https://www.jpan.ink/2017/02/06/Python-code/"/>
    <id>https://www.jpan.ink/2017/02/06/Python-code/</id>
    <published>2017-02-05T16:00:00.000Z</published>
    <updated>2019-03-17T15:33:29.741Z</updated>
    
    <content type="html"><![CDATA[<h4 id="字符编码详解"><a href="#字符编码详解" class="headerlink" title="字符编码详解"></a>字符编码详解</h4><ul><li>ASCII(American Standard Code for Information Interchange)，是一种单字节的编码。</li><li>发展为MBCS(Multi-Byte Character Set)，也叫做DBCS(Double-Byte Character Set)。根据你设定的区域不同，MBCS指代不同的编码，而Linux里无法使用MBCS作为编码。在Windows中又叫ANSI。同时，在简体中文Windows默认的区域设定里，指代GBK。</li><li>后来所有语言的字符都用同一种字符集来表示，这就是Unicode。统一两字节。</li><li>美国人创造了UTF-8，他是变长的，并且兼容ASCII，ASCII字符使用1字节表示。UTF-8里中文字符使用3个字节。</li></ul><h4 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h4><h5 id="str其实是字节串，unicode才是字符串。"><a href="#str其实是字节串，unicode才是字符串。" class="headerlink" title="str其实是字节串，unicode才是字符串。"></a>str其实是字节串，unicode才是字符串。</h5><p>对UTF-8编码的str’汉’使用len()函数时，结果是3，UTF-8编码的’汉’ == ‘\xE6\xB1\x89’。<br>len(u’汉’) == 1<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding: UTF-8</span></span><br><span class="line"> </span><br><span class="line">u = <span class="string">u'汉'</span></span><br><span class="line"><span class="keyword">print</span> repr(u) <span class="comment"># u'\u6c49'</span></span><br><span class="line">s = u.encode(<span class="string">'UTF-8'</span>)</span><br><span class="line"><span class="keyword">print</span> repr(s) <span class="comment"># '\xe6\xb1\x89'</span></span><br><span class="line">u2 = s.decode(<span class="string">'UTF-8'</span>)</span><br><span class="line"><span class="keyword">print</span> repr(u2) <span class="comment"># u'\u6c49'</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 对unicode进行解码是错误的</span></span><br><span class="line"><span class="comment"># s2 = u.decode('UTF-8')</span></span><br><span class="line"><span class="comment"># 同样，对str进行编码也是错误的</span></span><br><span class="line"><span class="comment"># u2 = s.encode('UTF-8')</span></span><br></pre></td></tr></table></figure></p><h5 id="读写"><a href="#读写" class="headerlink" title="读写"></a>读写</h5><p>内置的open()方法打开文件时，read()读取的是str，读取后需要使用正确的编码格式进行decode()。write()写入时，如果参数是unicode，则需要使用你希望写入的编码进行encode()，如果是其他编码格式的str，则需要先用该str的编码进行decode()，转成unicode后再使用写入的编码进行encode()</p><h5 id="sys-locale模块中提供了一些获取当前环境下的默认编码的方法。"><a href="#sys-locale模块中提供了一些获取当前环境下的默认编码的方法。" class="headerlink" title="sys/locale模块中提供了一些获取当前环境下的默认编码的方法。"></a>sys/locale模块中提供了一些获取当前环境下的默认编码的方法。</h5> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">import sys</span><br><span class="line">import locale</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 返回当前系统所使用的默认字符编码</span></span><br><span class="line">p(sys.getdefaultencoding)</span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash"> 返回用于转换Unicode文件名至系统文件名所使用的编码</span></span><br><span class="line">p(sys.getfilesystemencoding)</span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash"> 获取默认的区域设置并返回元祖(语言, 编码)</span></span><br><span class="line">p(locale.getdefaultlocale)</span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash"> 返回用户设定的文本数据编码</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 文档提到this <span class="keyword">function</span> only returns a guess</span></span><br><span class="line">p(locale.getpreferredencoding)</span><br></pre></td></tr></table></figure><h5 id="other"><a href="#other" class="headerlink" title="other"></a>other</h5><ul><li><p>抛弃str，全部使用unicode。</p></li><li><p>使用codecs.open()替代内置的open()</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;字符编码详解&quot;&gt;&lt;a href=&quot;#字符编码详解&quot; class=&quot;headerlink&quot; title=&quot;字符编码详解&quot;&gt;&lt;/a&gt;字符编码详解&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;ASCII(American Standard Code for Information Int
      
    
    </summary>
    
      <category term="Python" scheme="https://www.jpan.ink/categories/Python/"/>
    
    
      <category term="Python" scheme="https://www.jpan.ink/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Pickle-数据持久存储</title>
    <link href="https://www.jpan.ink/2017/02/06/Python-pickle/"/>
    <id>https://www.jpan.ink/2017/02/06/Python-pickle/</id>
    <published>2017-02-05T16:00:00.000Z</published>
    <updated>2019-03-17T15:19:45.464Z</updated>
    
    <content type="html"><![CDATA[<h4 id="pickle模块"><a href="#pickle模块" class="headerlink" title="pickle模块"></a>pickle模块</h4><ul><li>python的pickle模块实现了基本的数据序列和反序列化。通过pickle模块的序列化操作我们能够将程序中运行的对象信息保存到文件中去，永久存储；通过pickle模块的反序列化操作，我们能够从文件中创建上一次程序保存的对象</li></ul><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">　pickle.dump(obj, <span class="keyword">file</span>, [,protocol])</span><br><span class="line">　　注解：将对象obj保存到文件<span class="keyword">file</span>中去。</span><br><span class="line">　　　　　protocol为序列化使用的协议版本，<span class="number">0</span>：ASCII协议，所序列化的对象使用可打印的ASCII码表示；<span class="number">1</span>：老式的二进制协议；<span class="number">2</span>：<span class="number">2.3</span>版本引入的新二进制协议，较以前的更高效。其中协议<span class="number">0</span>和<span class="number">1</span>兼容老版本的<span class="keyword">python</span>。protocol默认值为<span class="number">0</span>。</span><br><span class="line">　　　　　<span class="keyword">file</span>：对象保存到的类文件对象。<span class="keyword">file</span>必须有<span class="keyword">write</span>()接口， <span class="keyword">file</span>可以是一个以<span class="string">'w'</span>方式打开的文件或者一个StringIO对象或者其他任何实现<span class="keyword">write</span>()接口的对象。如果protocol&gt;=<span class="number">1</span>，文件对象需要是二进制模式打开的。</span><br><span class="line"></span><br><span class="line">　pickle.load(<span class="keyword">file</span>)</span><br><span class="line">　　注解：从<span class="keyword">file</span>中读取一个字符串，并将它重构为原来的<span class="keyword">python</span>对象。</span><br><span class="line">　　<span class="keyword">file</span>:类文件对象，有<span class="keyword">read</span>()和readline()接口。</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;pickle模块&quot;&gt;&lt;a href=&quot;#pickle模块&quot; class=&quot;headerlink&quot; title=&quot;pickle模块&quot;&gt;&lt;/a&gt;pickle模块&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;python的pickle模块实现了基本的数据序列和反序列化。通过pickle模
      
    
    </summary>
    
      <category term="Pickle" scheme="https://www.jpan.ink/categories/Pickle/"/>
    
    
      <category term="Python" scheme="https://www.jpan.ink/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>结构化数据分析利器-Pandas</title>
    <link href="https://www.jpan.ink/2016/12/06/Pandas-trading/"/>
    <id>https://www.jpan.ink/2016/12/06/Pandas-trading/</id>
    <published>2016-12-05T16:00:00.000Z</published>
    <updated>2019-03-17T15:14:56.810Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://cloga.info/python/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/2013/09/17/pandasintro" target="_blank" rel="noopener">http://cloga.info/python/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/2013/09/17/pandasintro</a></p><ol><li>结构化数据分析利器-Pandas简介</li></ol><p>面板数据(Panel Data)<br>是将截面数据和时间序列数据综合起来的一种数据类型，该数据具有横截面和时间序列两个维度，当这类数据按两个维度进行排列时，数据都排在一个平面上，与排在一条线上的一维数据有着明显的不同，整个表格像是一个面板，所以称为面板数据(Panel Data)。</p><p>Pandas<br>Series：一维数组，与Numpy中的一维array类似。二者与Python基本的数据结构List也很相近，其区别是：List中的元素可以是不同的数据类型，而Array和Series中则只允许存储相同的数据类型，这样可以更有效的使用内存，提高运算效率。<br>Time- Series：以时间为索引的Series。<br>DataFrame：二维的表格型数据结构。很多功能与R中的data.frame类似。可以将DataFrame理解为Series的容器。以下的内容主要以DataFrame为主。<br>Panel ：三维的数组，可以理解为DataFrame的容器。</p><ol><li>【量化小讲堂 - python &amp; pandas技巧系列】使用python计算各类移动平均线</li></ol><p>计算移动平均线是最常见的需求，下面这段代码将完成以下三件事情：</p><ul><li><p>从csv格式的文件中导入股票数据，数据例图如下：</p></li><li><p>计算各类移动平均线，包括简单简单算术移动平均线MA、指数平滑移动平均线EMA；</p></li><li>将计算好的数据输出到csv文件中。</li></ul><p>代码应该复制下来就能运行了，关于从哪里可以得到代码中使用的数据，后面会讲，下面贴上代码（附件中也可以下载）：</p><hr><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">import pandas as pd</span><br><span class="line"><span class="meta"># ========== 从原始csv文件中导入股票数据，以浦发银行sh600000为例</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># 导入数据 - 注意：这里请填写数据文件在您电脑中的路径</span></span><br><span class="line">stock_data = pd.read_csv(<span class="string">'stock data/sh600000.csv'</span>, parse_dates=[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="meta"># 将数据按照交易日期从远到近排序</span></span><br><span class="line">stock_data.sort(<span class="string">'date'</span>, inplace=True)</span><br><span class="line"></span><br><span class="line"><span class="meta"># ========== 计算移动平均线</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># 分别计算5日、20日、60日的移动平均线</span></span><br><span class="line">ma_list = [<span class="number">5</span>, <span class="number">20</span>, <span class="number">60</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta"># 计算简单算术移动平均线MA - 注意：stock_data['close']为股票每天的收盘价</span></span><br><span class="line"><span class="keyword">for</span> ma in ma_list:</span><br><span class="line">    stock_data[<span class="string">'MA_'</span> + str(ma)] = pd.rolling_mean(stock_data[<span class="string">'close'</span>], ma)</span><br><span class="line"></span><br><span class="line"><span class="meta"># 计算指数平滑移动平均线EMA</span></span><br><span class="line"><span class="keyword">for</span> ma in ma_list:</span><br><span class="line">    stock_data[<span class="string">'EMA_'</span> + str(ma)] = pd.ewma(stock_data[<span class="string">'close'</span>], span=ma)</span><br><span class="line"></span><br><span class="line"><span class="meta"># 将数据按照交易日期从近到远排序</span></span><br><span class="line">stock_data.sort(<span class="string">'date'</span>, ascending=False, inplace=True)</span><br><span class="line"></span><br><span class="line"><span class="meta"># ========== 将算好的数据输出到csv文件 - 注意：这里请填写输出文件在您电脑中的路径</span></span><br><span class="line">stock_data.to_csv(<span class="string">'sh600000_ma_ema.csv'</span>, index=False)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;http://cloga.info/python/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/2013/09/17/pandasintro&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://clog
      
    
    </summary>
    
      <category term="Pandas" scheme="https://www.jpan.ink/categories/Pandas/"/>
    
    
      <category term="Python" scheme="https://www.jpan.ink/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Mysql性能优化</title>
    <link href="https://www.jpan.ink/2016/06/20/Mysql-optimization/"/>
    <id>https://www.jpan.ink/2016/06/20/Mysql-optimization/</id>
    <published>2016-06-19T16:00:00.000Z</published>
    <updated>2019-03-17T15:09:42.271Z</updated>
    
    <content type="html"><![CDATA[<p> 案例<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="string">`xvideos`</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">Between</span> 方式</span><br><span class="line">===========================</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> xvideos</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">id</span> <span class="keyword">BETWEEN</span> <span class="number">3643710</span> <span class="keyword">AND</span> <span class="number">3643710</span> + <span class="number">30</span> - <span class="number">1</span></span><br><span class="line">查询花费 <span class="number">0.0007</span> 秒</span><br><span class="line"></span><br><span class="line"><span class="keyword">Where</span> <span class="keyword">ID</span> 方式</span><br><span class="line">===========================</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> xvideos</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">id</span> &gt; <span class="number">3643710</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">id</span></span><br><span class="line"><span class="keyword">LIMIT</span> <span class="number">30</span></span><br><span class="line">查询花费 <span class="number">0.0379</span> 秒</span><br><span class="line"><span class="keyword">Limit</span>方式</span><br><span class="line">===========================</span><br><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> xvideos</span><br><span class="line"><span class="keyword">LIMIT</span> <span class="number">3643710</span> , <span class="number">30</span></span><br><span class="line">查询花费 <span class="number">19.3808</span> 秒</span><br><span class="line"></span><br><span class="line">SubQuery 子查询方式</span><br><span class="line">===========================</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> xvideos <span class="keyword">WHERE</span> <span class="keyword">id</span> &gt;</span><br><span class="line">(<span class="keyword">SELECT</span> <span class="keyword">id</span> <span class="keyword">FROM</span> xvideos <span class="keyword">LIMIT</span> <span class="number">3643709</span>, <span class="number">1</span>) <span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">id</span> <span class="keyword">asc</span> <span class="keyword">LIMIT</span> <span class="number">30</span></span><br><span class="line">查询花费 <span class="number">1.8362</span> 秒</span><br><span class="line"></span><br><span class="line"><span class="keyword">JOIN</span> 方式</span><br><span class="line">===========================</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> xvideos <span class="keyword">AS</span> t1</span><br><span class="line"><span class="keyword">JOIN</span> (<span class="keyword">SELECT</span> <span class="keyword">id</span> <span class="keyword">FROM</span> xvideos <span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">id</span> <span class="keyword">asc</span> <span class="keyword">LIMIT</span> <span class="number">3643709</span>, <span class="number">1</span>) <span class="keyword">AS</span> t2</span><br><span class="line"><span class="keyword">WHERE</span> t1.id &lt;= t2.id <span class="keyword">ORDER</span> <span class="keyword">BY</span> t1.id <span class="keyword">desc</span> <span class="keyword">LIMIT</span> <span class="number">30</span>;</span><br><span class="line">查询花费 1.1632 秒</span><br></pre></td></tr></table></figure></p><h4 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h4><ol><li>当一个数据库表过于庞大，LIMIT offset, length中的offset值过大，则SQL查询语句会非常缓慢，你需增加order by，并且order by字段需要建立索引。</li><li><p>如果使用子查询去优化LIMIT的话，则子查询必须是连续的，某种意义来讲，子查询不应该有where条件，where会过滤数据，使数据失去连续性。（where需要复合索引）。如果你查询的记录比较大，并且数据传输量比较大，比如包含了text类型的field，则可以通过建立子查询。<br>当偏移1000以上使用子查询法可以有效的提高性能。</p><pre><code>SELECT id,title,content FROM items WHERE id IN (SELECT id FROM items ORDER BY id limit 900000, 10);</code></pre></li></ol><ol><li><p>如果limit语句的offset较大，你可以通过传递pk键值来减小offset = 0，这个主键最好是int类型并且auto_increment</p><pre><code>SELECT * FROM users WHERE uid &gt;= (SELECT uid FROM users ORDER BY uid limit 895682, 1) limit 0, 10;</code></pre></li></ol><ol><li>如果limit的offset值过大，用户也会翻页疲劳，你可以设置一个offset最大的，超过了可以另行处理，一般连续翻页过大，用户体验很差，则应该提供更优的用户体验给用户。</li></ol><h4 id="limit-分页优化方法"><a href="#limit-分页优化方法" class="headerlink" title="limit 分页优化方法"></a>limit 分页优化方法</h4><ol><li><p>子查询优化法<br>从结果中可以得知，当偏移1000以上使用子查询法可以有效的提高性能。</p></li><li><p>倒排表优化法<br>倒排表法类似建立索引，用一张表来维护页数，然后通过高效的连接得到数据。缺点：只适合数据数固定的情况，数据不能删除，维护页表困难</p></li><li><p>反向查找优化法<br>当偏移超过一半记录数的时候，先用排序，这样偏移就反转了。缺点：order by优化比较麻烦，要增加索引，索引影响数据的修改效率，并且要知道总记录数，偏移大于数据的一半</p></li></ol><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">更新 date: 2019<span class="string">-02</span><span class="string">-20</span></span><br></pre></td></tr></table></figure><h3 id="了解Mysql的引擎"><a href="#了解Mysql的引擎" class="headerlink" title="了解Mysql的引擎"></a>了解Mysql的引擎</h3><h3 id="Mysql优化可以从三个角度"><a href="#Mysql优化可以从三个角度" class="headerlink" title="Mysql优化可以从三个角度"></a>Mysql优化可以从三个角度</h3><h4 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h4><h5 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h5><blockquote><p>FULLTEXT，HASH，BTREE，RTREE</p></blockquote><h5 id="种类"><a href="#种类" class="headerlink" title="种类"></a>种类</h5><ul><li>普通索引：仅加速查询</li><li>唯一索引：加速查询 + 列值唯一（可以有null）</li><li>主键索引：加速查询 + 列值唯一（不可以有null）+ 表中只有一个</li><li>组合索引：多列值组成一个索引，专门用于组合搜索，其效率大于索引合并</li><li>全文索引：对文本的内容进行分词，进行搜索</li></ul><h4 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h4><blockquote><p>行锁，表锁，页锁</p></blockquote><h4 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h4><h5 id="explain"><a href="#explain" class="headerlink" title="explain"></a>explain</h5><ul><li>select_type<br>select查询的类型，主要是区别普通查询和联合查询、子查询之类的复杂查询。</li><li>type<br>联合查询所使用的类型。<br>type显示的是访问类型，是较为重要的一个指标，结果值从好到坏依次是：<br>system &gt; const &gt; eq_ref &gt; ref &gt; fulltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; range &gt; index &gt; ALL</li></ul><p>！[美团案例]:(<a href="https://tech.meituan.com/2014/06/30/mysql-index.html" target="_blank" rel="noopener">https://tech.meituan.com/2014/06/30/mysql-index.html</a>)</p>]]></content>
    
    <summary type="html">
    
      Mysql性能优化
    
    </summary>
    
      <category term="Mysql" scheme="https://www.jpan.ink/categories/Mysql/"/>
    
    
      <category term="Performance-optimization" scheme="https://www.jpan.ink/tags/Performance-optimization/"/>
    
  </entry>
  
  <entry>
    <title>PHP基础语法</title>
    <link href="https://www.jpan.ink/2016/06/20/PHP-note/"/>
    <id>https://www.jpan.ink/2016/06/20/PHP-note/</id>
    <published>2016-06-19T16:00:00.000Z</published>
    <updated>2019-03-17T15:35:05.881Z</updated>
    
    <content type="html"><![CDATA[<h4 id="PHP-脚本"><a href="#PHP-脚本" class="headerlink" title="PHP 脚本"></a>PHP 脚本</h4><p>可放置于文档中的任何位置。<br>PHP 脚本以 &lt;?php 开头，以 ?&gt; 结尾：<br><a id="more"></a></p><pre><code>&lt;?php// 此处是 PHP 代码?&gt;</code></pre><p>PHP 文件的默认文件扩展名是 “.php”。</p><p>PHP 文件通常包含 HTML 标签以及一些 PHP 脚本代码。</p><h4 id="PHP-支持三种注释："><a href="#PHP-支持三种注释：" class="headerlink" title="PHP 支持三种注释："></a>PHP 支持三种注释：</h4><pre><code>// 这是单行注释# 这也是单行注释/*这是多行注释块多行*/</code></pre><h4 id="PHP-大小写敏感"><a href="#PHP-大小写敏感" class="headerlink" title="PHP 大小写敏感"></a>PHP 大小写敏感</h4><p>在 PHP 中，所有用户定义的函数、类和关键词（例如 if、else、echo 等等）都对大小写不敏感。</p><p>所有变量都对大小写敏感。</p><h4 id="PHP-变量规则："><a href="#PHP-变量规则：" class="headerlink" title="PHP 变量规则："></a>PHP 变量规则：</h4><p>变量以 $ 符号开头，其后是变量的名称<br>变量名称必须以字母或下划线开头<br>变量名称不能以数字开头<br>变量名称只能包含字母数字字符和下划线（A-z、0-9 以及 _）<br>变量名称对大小写敏感（$y 与 $Y 是两个不同的变量）</p><h4 id="PHP-有三种不同的变量作用域："><a href="#PHP-有三种不同的变量作用域：" class="headerlink" title="PHP 有三种不同的变量作用域："></a>PHP 有三种不同的变量作用域：</h4><p>local（局部）<br>global（全局）<br>static（静态）<br>函数之外声明的变量拥有 Global 作用域，只能在函数以外进行访问。</p><p>函数内部声明的变量拥有 LOCAL 作用域，只能在函数内部进行访问。 通常，当函数完成/执行后，会删除所有变量。</p><h4 id="PHP-global-关键词"><a href="#PHP-global-关键词" class="headerlink" title="PHP global 关键词"></a>PHP global 关键词</h4><p>global 关键词用于在函数内 访问全局变量。<br>要做到这一点，请在（函数内部）变量前面使用 global 关键词：<br>global $x,$y;<br> $GLOBALS[‘y’]=$GLOBALS[‘x’]+$GLOBALS[‘y’];</p><h4 id="PHP-static-关键词"><a href="#PHP-static-关键词" class="headerlink" title="PHP static 关键词"></a>PHP static 关键词</h4><p>首次声明变量时使用 static 关键词，不删除某个局部变量。<br>每当函数被调用时，这个变量所存储的信息都是函数最后一次被调用时所包含的信息。</p><p>注释：该变量仍然是函数的局部变量。</p><h4 id="PHP-echo-和-print-语句"><a href="#PHP-echo-和-print-语句" class="headerlink" title="PHP echo 和 print 语句"></a>PHP echo 和 print 语句</h4><p>echo 和 print 之间的差异：</p><p>echo - 能够输出一个以上的字符串<br>print - 只能输出一个字符串，并始终返回 1</p><p>提示：echo 比 print 稍快，因为它不返回任何值。</p><p>使用方法一致。<br>都是语言结构，有无括号均可使用， 字符串中能包含 HTML 标记</p><pre><code>&lt;?phpecho &quot;&lt;h2&gt;PHP is fun!&lt;/h2&gt;&quot;;echo &quot;Hello world!&lt;br&gt;&quot;;echo &quot;I&apos;m about to learn PHP!&lt;br&gt;&quot;;echo &quot;This&quot;, &quot; string&quot;, &quot; was&quot;, &quot; made&quot;, &quot; with multiple parameters.&quot;;echo $txt1;echo &quot;&lt;br&gt;&quot;;echo &quot;Study PHP at $txt2&quot;;echo &quot;&lt;br&gt;&quot;;echo &quot;My car is a {$cars[0]}&quot;;?&gt;</code></pre><h4 id="PHP-字符串"><a href="#PHP-字符串" class="headerlink" title="PHP 字符串"></a>PHP 字符串</h4><p>字符串可以是引号内的任何文本。可以使用单引号或双引</p><h4 id="PHP-逻辑"><a href="#PHP-逻辑" class="headerlink" title="PHP 逻辑"></a>PHP 逻辑</h4><p>逻辑是 true 或 false。</p><pre><code>$x=true;$y=false;</code></pre><h4 id="yii框架"><a href="#yii框架" class="headerlink" title="yii框架"></a>yii框架</h4><p>has one、many和belongs_to的属性所在表刚好相反<br>belongs_to 当前的多对一<br>has many 1对多</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;PHP-脚本&quot;&gt;&lt;a href=&quot;#PHP-脚本&quot; class=&quot;headerlink&quot; title=&quot;PHP 脚本&quot;&gt;&lt;/a&gt;PHP 脚本&lt;/h4&gt;&lt;p&gt;可放置于文档中的任何位置。&lt;br&gt;PHP 脚本以 &amp;lt;?php 开头，以 ?&amp;gt; 结尾：&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="PHP" scheme="https://www.jpan.ink/categories/PHP/"/>
    
    
      <category term="Base-notes" scheme="https://www.jpan.ink/tags/Base-notes/"/>
    
  </entry>
  
  <entry>
    <title>Js传递多值</title>
    <link href="https://www.jpan.ink/2016/05/11/Js-dup-param/"/>
    <id>https://www.jpan.ink/2016/05/11/Js-dup-param/</id>
    <published>2016-05-10T16:00:00.000Z</published>
    <updated>2019-03-28T15:27:24.379Z</updated>
    
    <content type="html"><![CDATA[<p>onclick=”test_click(‘+ a +’,\’’+ b +’\’)”<br>注意单双引号的嵌套，转义字符的使用</p><p>detail(‘${type.id}’,’ ${type.name}’)”</p><p>.html()用为读取和修改元素的HTML标签</p><p>.text()用来读取或修改元素的纯文本内容 dev或者a或者label</p><p>.val()用来读取或修改表单元素的value值。只可用于input</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;onclick=”test_click(‘+ a +’,\’’+ b +’\’)”&lt;br&gt;注意单双引号的嵌套，转义字符的使用&lt;/p&gt;
&lt;p&gt;detail(‘${type.id}’,’ ${type.name}’)”&lt;/p&gt;
&lt;p&gt;.html()用为读取和修改元素的HTML标
      
    
    </summary>
    
      <category term="JS" scheme="https://www.jpan.ink/categories/JS/"/>
    
    
      <category term="Web" scheme="https://www.jpan.ink/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>Jq基础语法</title>
    <link href="https://www.jpan.ink/2016/04/22/Jq-note/"/>
    <id>https://www.jpan.ink/2016/04/22/Jq-note/</id>
    <published>2016-04-21T16:00:00.000Z</published>
    <updated>2019-03-28T15:27:17.002Z</updated>
    
    <content type="html"><![CDATA[<p>w3c网站学习笔记</p><ul><li><p>jQuery 为HTML元素服务</p></li><li><p>语法是Xpath和CSS选择器语法结合</p><pre><code>$(this).hide()   this ：html元素\#text   id=test   this#text.test   class=test   this.class$(selector).action()$(document).ready(function(){    })</code></pre></li><li><p>括号内  选择器要加双引号</p></li><li><p>使用XPath表达式选择带有给定属性的元素</p></li></ul><pre><code>$(“[href]”)$(“[href  =’    ’]”)    完全匹配$(“[href  !=’    ‘]”)$(“[href$ =’.jpg’]”)      以。。。结尾$(“ul li:first”)$(“div#intro.head”)</code></pre><ul><li><p>JQuery 为事件处理特别设计的</p></li><li><p>通常放到<head>部分</head></p></li><li><p>多页面，希望jq易于维护，放到js文件里面</p><pre><code>&lt;head&gt;&lt;script type=”text/javascript” src=“XXXX.js” &gt;&lt;/script&gt;&lt;/head&gt;</code></pre></li><li><p>Jq $冲突</p><pre><code>Var jq =jQuery.noConflict();$.noConflict();  默认用jQuery代替$</code></pre></li><li><p>jQuery事件</p><pre><code>$(document).ready(  )$(selector).click(  )$(selector).dblclick(   )$(selector).focus(  )$(selector).mouseover()</code></pre></li></ul><h3 id="jQuery-效果"><a href="#jQuery-效果" class="headerlink" title="jQuery 效果"></a>jQuery 效果</h3><p>默认校验规则</p><p>(1)required:true 必输字段</p><p>(2)remote:”check.php” 使用ajax方法调用check.php验证输入值</p><p>(3)email:true 必须输入正确格式的电子邮件</p><p>(4)url:true 必须输入正确格式的网址</p><p>(5)date:true 必须输入正确格式的日期</p><p>(6)dateISO:true 必须输入正确格式的日期(ISO)，例如：2009-06-23，1998/01/22 只验证格式，不验证有效性</p><p>(7)number:true 必须输入合法的数字(负数，小数)</p><p>(8)digits:true 必须输入整数</p><p>(9)creditcard: 必须输入合法的信用卡号</p><p>(10)equalTo:”#field” 输入值必须和#field相同</p><p>(11)accept: 输入拥有合法后缀名的字符串（上传文件的后缀）</p><p>(12)maxlength:5 输入长度最多是5的字符串(汉字算一个字符)</p><p>(13)minlength:10 输入长度最小是10的字符串(汉字算一个字符)</p><p>(14)rangelength:[5,10] 输入长度必须介于 5 和 10 之间的字符串”)(汉字算一个字符)</p><p>(15)range:[5,10] 输入值必须介于 5 和 10 之间</p><p>(16)max:5 输入值不能大于5</p><p>(17)min:10 输入值不能小于10</p>]]></content>
    
    <summary type="html">
    
      notes
    
    </summary>
    
      <category term="Jquery" scheme="https://www.jpan.ink/categories/Jquery/"/>
    
    
      <category term="Base-notes" scheme="https://www.jpan.ink/tags/Base-notes/"/>
    
  </entry>
  
  <entry>
    <title>Js基础语法</title>
    <link href="https://www.jpan.ink/2016/04/22/Js-note/"/>
    <id>https://www.jpan.ink/2016/04/22/Js-note/</id>
    <published>2016-04-21T16:00:00.000Z</published>
    <updated>2019-03-28T15:27:31.128Z</updated>
    
    <content type="html"><![CDATA[<p>w3c网站学习笔记</p><ul><li><p>大小写区分</p></li><li><p>忽略空格</p></li><li><p>单引号和双引号作用一致</p></li><li><p>；可加可不加</p></li><li><p>var carname=”Volvo”; var carname;值不变</p></li><li><p>var cars = new Array（）；</p></li><li><p>cars[0]=“”</p></li><li><p>数组下标从0开始</p></li><li><p>对象定义与寻址</p></li><li><p>字符串对象（所有事务都是对象）</p></li><li><p>txt.length=5</p></li><li><p>txt.indexOf()</p></li><li><p>txt.replace()</p></li><li><p>txt.search()</p></li><li><p>alert（““） 弹窗提示</p></li><li><p>函数外申明的变量是全局变量，网页上所有脚本和函数都可以访问它。可以</p></li><li><p>输出</p></li><li><p>document.getElementById(“demo”).innerHTML=”My First JavaScript”;+ document.write(“</p><p>My First JavaScript</p>“); <p></p></li><li><p>字符串变量+ 表示连接</p></li></ul><ul><li><p>数字和字符串相加得到字符串</p></li><li><p>=== 全等</p></li><li><p>In</p></li><li><p>var person={fname:”John”,lname:”Doe”,age:25};</p></li><li></li><li>for (x in person)</li><li>{</li><li>txt=txt + person[x];</li><li>}</li></ul><p>Js验证<br><a href="http://www.w3school.com.cn/js/js_form_validation.asp" target="_blank" rel="noopener">http://www.w3school.com.cn/js/js_form_validation.asp</a></p>]]></content>
    
    <summary type="html">
    
      notes
    
    </summary>
    
      <category term="JS" scheme="https://www.jpan.ink/categories/JS/"/>
    
    
      <category term="Base-notes" scheme="https://www.jpan.ink/tags/Base-notes/"/>
    
  </entry>
  
</feed>
